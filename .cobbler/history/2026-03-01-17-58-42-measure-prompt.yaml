role: |
    You are a software architect planning work for an AI code generation pipeline. Each task you propose will be executed by a separate Claude instance (the "stitch agent") that sees only its task description and the project rules. The stitch agent has no memory of this conversation and no access to your analysis.
project_context:
    vision:
        file: docs/VISION.yaml
        id: sdd-hello-world
        title: SDD Hello World
        executive_summary: |
            We build a minimal Go command-line application that prints "Hello, World!" to
            standard output and exits with code 0. The project exists as a test fixture
            for the cobbler-scaffold orchestrator. It validates that scaffold push,
            measure, stitch, and generator lifecycle targets work correctly against a
            real Go module published on the Go module proxy.
        problem: |
            The cobbler-scaffold end-to-end tests need a stable, minimal Go project to
            scaffold and exercise mage targets against. Using a large, actively developed
            project like go-unix-utils couples test stability to ongoing spec changes.
            A dedicated test fixture isolates cobbler-scaffold validation from production
            project evolution.
        what_this_does: |
            We provide the simplest possible Go binary (one file, zero external
            dependencies) wrapped in the SDD project structure. The project has a VISION
            document so cobbler's measure phase has a specification to read. The project
            is tagged and published as a Go module so PrepareTestRepo can download it
            via the Go module proxy.
        why_we_build_this: |
            Cobbler-scaffold needs a test target that is small, stable, and exercises the
            full scaffolding pipeline. This project fills that role. It decouples test
            reliability from changes in go-unix-utils or crumbs.
        success_criteria:
            build_correctness: |
                go build ./cmd/sdd-hello-world succeeds with exit code 0.
            module_availability: |
                go list -m -versions returns at least one tagged version.
            runtime_correctness: |
                Binary prints exactly 'Hello, World!' followed by a newline and exits 0.
            scaffold_compatibility: |
                mage scaffold:push produces a working orchestrator setup; mage -l lists all targets.
        implementation_phases:
            - phase: "1"
              focus: Initial project
              deliverables: go.mod, main.go, VISION.yaml, LICENSE, README.md
            - phase: "2"
              focus: Scaffold integration
              deliverables: Scaffolded orchestrator files, configuration.yaml, tagged release
        risks:
            - risk: Go module proxy caching delay
              impact: Low
              likelihood: Low
              mitigation: Wait for proxy propagation before running e2e tests
        not:
            - We do not handle command-line arguments, read input, write to files, or use external packages.
            - We do not write tests beyond what cobbler-scaffold's e2e suite provides.
            - This is not a template for production SDD projects; it is a test fixture.
    architecture:
        file: docs/ARCHITECTURE.yaml
        id: architecture-sdd-hello-world
        title: SDD Hello World Architecture
        overview:
            summary: |
                SDD Hello World is a minimal Go command-line application and cobbler-scaffold
                test fixture. It consists of one Go source file that prints "Hello, World!" and
                exits with code 0, wrapped in the SDD project structure. The magefiles directory
                holds the scaffolded orchestrator targets that cobbler-scaffold exercises during
                its end-to-end tests.
            lifecycle: |
                The project has two lifecycle phases. Phase 1 established the initial Go binary
                and documentation. Phase 2 integrated the cobbler-scaffold orchestrator via
                mage scaffold:push, producing configuration.yaml and magefiles/orchestrator.go.
                The project is tagged and published as a Go module so PrepareTestRepo can
                download it via the Go module proxy.
            coordination_pattern: |
                There is no runtime coordination. The binary is a single-shot process: it writes
                to stdout and exits. The Mage targets delegate to the cobbler-scaffold orchestrator
                library, which manages measure-stitch cycles and generator lifecycle operations
                against this project when invoked during cobbler-scaffold end-to-end tests.
        interfaces:
            - name: Binary CLI
              summary: |
                The compiled binary accepts no flags or arguments. It writes "Hello, World!\n"
                to stdout and exits with code 0.
              operations:
                - 'main(): write ''Hello, World!'' to stdout and exit 0'
            - name: Mage Targets
              summary: |
                The magefiles/orchestrator.go file exposes orchestrator methods as Mage targets.
                These targets are invoked by cobbler-scaffold's end-to-end tests.
              data_structures:
                - 'Orchestrator: instantiated from configuration.yaml via NewFromFile()'
              operations:
                - 'Build(): compile the sdd-hello-world binary'
                - 'Cobbler:Measure(): propose tasks via the orchestrator measure phase'
                - 'Cobbler:Stitch(): execute tasks via the orchestrator stitch phase'
                - 'Scaffold:Push(): scaffold orchestrator into this project'
                - 'Generator:Start/Run/Stop(): generation lifecycle'
                - 'Analyze(): cross-artifact consistency checking'
                - 'Tag(): create a versioned doc-release tag'
        components:
            - name: Binary
              responsibility: |
                Single-file Go program. Writes "Hello, World!\n" to stdout and exits 0.
                Zero external dependencies. The file also defines a Version constant
                populated at generation time via cmd/sdd-hello-world/version.go.
              capabilities:
                - Print "Hello, World!" to stdout
                - Exit with code 0
            - name: Magefiles
              responsibility: |
                Scaffolded orchestrator targets. magefiles/orchestrator.go instantiates
                the cobbler-scaffold Orchestrator from configuration.yaml and exposes its
                methods as Mage build targets. This file is generated by mage scaffold:push
                and updated by cobbler-scaffold's E2E test suite via PrepareTestRepo.
              capabilities:
                - Expose orchestrator lifecycle, cobbler, scaffold, analyze, and tag targets
                - Load configuration from configuration.yaml via NewFromFile()
        design_decisions:
            - id: 1
              title: Zero-dependency binary
              decision: |
                The binary uses only the Go standard library. No external packages are added
                to go.mod beyond the go directive itself.
              benefits:
                - Eliminates dependency churn that could affect cobbler-scaffold test stability
                - Keeps the module minimal and fast to download via the Go module proxy
              alternatives_rejected:
                - 'Adding helper packages: unnecessary complexity for a test fixture'
            - id: 2
              title: Specification-driven code generation
              decision: |
                We include a PRD (prd001-hello-world-binary), a use case, and a test suite
                that specify the binary's requirements. The cobbler-scaffold measure phase
                reads these specifications and proposes implementation tasks when the Go
                source files are absent. This makes the project a reliable, reproducible
                target for the generation pipeline.
              benefits:
                - The measure agent has anchored requirements to propose tasks against
                - Each generation cycle can produce the binary from specifications alone
                - The test suite validates that generated code meets the PRD requirements
              alternatives_rejected:
                - 'No specs: measure agent finds nothing to propose when source is absent'
        technology_choices:
            - component: Language
              technology: Go
              purpose: Single-file binary with standard library only
            - component: Build system
              technology: Magefile (magefile/mage)
              purpose: Scaffolded orchestrator targets; invoked by cobbler-scaffold E2E tests
            - component: Module registry
              technology: Go module proxy (proxy.golang.org)
              purpose: PrepareTestRepo downloads this module at a tagged version for E2E tests
        project_structure:
            - path: cmd/sdd-hello-world/main.go
              role: Binary entry point; prints Hello, World! and exits 0
            - path: cmd/sdd-hello-world/version.go
              role: Version constant (seed file, populated at generation time)
            - path: magefiles/orchestrator.go
              role: Scaffolded Mage targets delegating to cobbler-scaffold Orchestrator
            - path: magefiles/go.mod
              role: Magefiles module, depends on cobbler-scaffold
            - path: configuration.yaml
              role: Orchestrator configuration (module path, binary name, prompt paths)
            - path: docs/
              role: Project documentation and constitutions
            - path: go.mod
              role: Go module definition (no external dependencies)
        implementation_status:
            current_focus: Release 02.0 — implement binary from specifications
            progress:
                - done: Scaffolded mage targets (magefiles/orchestrator.go)
                - done: Configuration (configuration.yaml)
                - done: Documentation (VISION.yaml, ARCHITECTURE.yaml, road-map.yaml, constitutions)
                - done: Tagged and published as Go module
                - done: PRD, use case, and test suite for hello world binary
                - pending: Go binary (cmd/sdd-hello-world/main.go, cmd/sdd-hello-world/version.go)
        related_documents:
            - doc: docs/VISION.yaml
              purpose: Project purpose, scope, and success criteria
            - doc: docs/road-map.yaml
              purpose: Release schedule and phase status
            - doc: docs/specs/product-requirements/prd001-hello-world-binary.yaml
              purpose: Binary requirements (file structure, runtime behavior)
            - doc: docs/specs/use-cases/rel02.0-uc001-build-hello-world.yaml
              purpose: Build and run use case for release 02.0
            - doc: docs/specs/test-suites/test-rel02.0.yaml
              purpose: Test suite validating the binary use case
            - doc: configuration.yaml
              purpose: Orchestrator configuration
    specifications:
        file: docs/SPECIFICATIONS.yaml
        id: specifications-sdd-hello-world
        title: SDD Hello World Specifications
        overview: |
            SDD Hello World is a minimal test fixture for cobbler-scaffold. The project
            specifies a Go binary that prints "Hello, World!" and exits 0. The
            cobbler-scaffold generation pipeline reads the PRD and produces the Go source
            files. For goals and boundaries see VISION.yaml. For components and structure
            see ARCHITECTURE.yaml.
        roadmap_summary:
            - version: "01.0"
              name: Initial project and scaffold integration
              use_cases_done: 0
              use_cases_total: 0
              status: done
            - version: "02.0"
              name: Hello world binary from specifications
              use_cases_done: 0
              use_cases_total: 1
              status: pending
        prd_index:
            - id: prd001-hello-world-binary
              title: Hello World Binary
              summary: |
                Specifies the Go binary that prints "Hello, World!" and exits 0. Covers
                file structure (main.go, version.go), runtime behavior, and zero-dependency
                constraint.
              path: docs/specs/product-requirements/prd001-hello-world-binary.yaml
        use_case_index:
            - id: rel02.0-uc001-build-hello-world
              title: Build and Run Hello World Binary
              release: "02.0"
              status: pending
              test_suite: test-rel02.0
              path: docs/specs/use-cases/rel02.0-uc001-build-hello-world.yaml
        test_suite_index:
            - id: test-rel02.0
              title: Test Suite for Release 02.0 — Hello World Binary
              release: ""
              traces:
                - rel02.0-uc001-build-hello-world
              test_case_count: 5
              path: docs/specs/test-suites/test-rel02.0.yaml
        prd_to_use_case_mapping:
            - use_case: rel02.0-uc001-build-hello-world
              prd: prd001-hello-world-binary
              why_required: |
                The use case exercises all PRD requirements by building and running the
                binary, verifying output, exit code, and file structure.
              coverage: R1.1, R1.2, R1.3, R2.1, R2.2, R2.3
        coverage_gaps: |
            No coverage gaps. All prd001-hello-world-binary requirements are covered by
            the rel02.0-uc001-build-hello-world use case and its test suite.
        references:
            - VISION.yaml
            - ARCHITECTURE.yaml
            - road-map.yaml
    roadmap:
        file: docs/road-map.yaml
        id: sdd-hello-world-roadmap
        title: SDD Hello World Roadmap
        releases:
            - version: "01.0"
              name: Initial project and scaffold integration
              status: done
              description: |
                Minimal Go binary, SDD project structure, and cobbler-scaffold integration.
                Phase 1 delivered the binary and documentation. Phase 2 scaffolded the
                orchestrator mage targets, published the module to the Go module proxy,
                and validated the full cobbler-scaffold E2E pipeline.
              use_cases: []
            - version: "02.0"
              name: Hello world binary from specifications
              status: pending
              description: |
                We implement the hello world binary from its PRD specification. The
                generation pipeline reads prd001-hello-world-binary and produces the Go
                source files. This release validates that cobbler-scaffold can generate
                code from specs in a clean repository.
              use_cases:
                - id: rel02.0-uc001-build-hello-world
                  status: pending
        prioritization:
            - Release 02.0 implements the binary from specifications so the generation pipeline has reproducible work to propose and execute.
    specs:
        product_requirements:
            - file: docs/specs/product-requirements/prd001-hello-world-binary.yaml
              id: prd001-hello-world-binary
              title: Hello World Binary
              problem: |
                The cobbler-scaffold orchestrator needs a minimal Go binary to exercise its
                measure and stitch pipeline against. The binary must be simple enough that a
                single generation cycle can produce it from specifications alone, yet
                complete enough to validate that the pipeline creates compilable, runnable
                Go code. Without a PRD that specifies the binary's requirements, the measure
                agent has no anchored requirements to propose and proposes zero tasks.
              goals:
                - id: G1
                  text: |
                    Provide a compilable Go binary that prints a greeting and exits
                    successfully, serving as a reproducible target for cobbler-scaffold
                    code generation.
                - id: G2
                  text: |
                    Specify the binary precisely enough that the measure agent can propose
                    implementation tasks anchored to numbered requirements.
              requirements:
                R1:
                    title: Binary structure
                    items:
                        - R1.1: The binary must have its entry point at cmd/sdd-hello-world/main.go with a main function in package main.
                        - R1.2: The binary must have a version file at cmd/sdd-hello-world/version.go that declares a Version constant of type string in package main.
                        - R1.3: The binary must use only the Go standard library. The go.mod file must not declare any external dependencies.
                R2:
                    title: Runtime behavior
                    items:
                        - R2.1: The binary must print exactly "Hello, World!" followed by a newline character to standard output.
                        - R2.2: The binary must exit with code 0 after printing.
                        - R2.3: The binary must accept no command-line arguments and produce no other output.
              non_goals:
                - Reading input from stdin or files
                - Handling command-line flags or arguments
                - Using external packages or dependencies
                - Writing tests within this project (cobbler-scaffold's E2E suite provides coverage)
              acceptance_criteria:
                - go build ./cmd/sdd-hello-world succeeds with exit code 0.
                - Running the compiled binary produces exactly "Hello, World!\n" on stdout and exits with code 0.
                - cmd/sdd-hello-world/main.go exists with a main function.
                - cmd/sdd-hello-world/version.go exists with a Version constant.
        use_cases:
            - file: docs/specs/use-cases/rel02.0-uc001-build-hello-world.yaml
              id: rel02.0-uc001-build-hello-world
              title: Build and Run Hello World Binary
              summary: |
                We compile the sdd-hello-world Go binary from source and verify that it
                produces the expected output. This use case exercises the full path from
                Go source to running binary, validating that the code generated by the
                cobbler-scaffold pipeline is correct.
              actor: Developer or CI pipeline
              trigger: |
                Go source files exist at cmd/sdd-hello-world/main.go and
                cmd/sdd-hello-world/version.go after a generation cycle completes.
              flow:
                - id: F1
                  text: Run go build ./cmd/sdd-hello-world to compile the binary.
                - id: F2
                  text: Verify the build succeeds with exit code 0.
                - id: F3
                  text: Run the compiled binary.
                - id: F4
                  text: Capture stdout and the exit code.
                - id: F5
                  text: Verify stdout contains exactly "Hello, World!\n" and exit code is 0.
              touchpoints:
                - id: T1
                  text: |
                    Binary component (cmd/sdd-hello-world/main.go) — exercises the main
                    function that prints the greeting. Implements prd001-hello-world-binary
                    R1.1, R2.1, R2.2, R2.3.
                - id: T2
                  text: |
                    Version file (cmd/sdd-hello-world/version.go) — confirms the version
                    constant compiles alongside main.go. Implements prd001-hello-world-binary
                    R1.2.
                - id: T3
                  text: |
                    Go module (go.mod) — validates that the module builds with zero external
                    dependencies. Implements prd001-hello-world-binary R1.3.
              success_criteria:
                - id: S1
                  text: go build ./cmd/sdd-hello-world exits with code 0.
                - id: S2
                  text: The binary prints "Hello, World!\n" to stdout.
                - id: S3
                  text: The binary exits with code 0.
              out_of_scope:
                - Testing with command-line arguments or flags
                - Cross-compilation or platform-specific behavior
                - Performance benchmarking
              test_suite: test-rel02.0
        test_suites:
            - file: docs/specs/test-suites/test-rel02.0.yaml
              id: test-rel02.0
              title: Test Suite for Release 02.0 — Hello World Binary
              release: "02.0"
              traces:
                - rel02.0-uc001-build-hello-world
              preconditions:
                - Go source files cmd/sdd-hello-world/main.go and cmd/sdd-hello-world/version.go exist in the repository.
                - The go.mod file declares the module path github.com/petar-djukic/sdd-hello-world with no external dependencies.
              test_cases:
                - name: Build succeeds
                  inputs: |
                    Run go build ./cmd/sdd-hello-world from the repository root.
                  expected: |
                    The command exits with code 0 and produces a compiled binary.
                - name: Binary prints greeting
                  inputs: |
                    Run the compiled sdd-hello-world binary with no arguments.
                  expected: |
                    Stdout contains exactly "Hello, World!" followed by a newline. No other
                    output is produced.
                - name: Binary exits with code 0
                  inputs: |
                    Run the compiled sdd-hello-world binary and capture the exit code.
                  expected: |
                    The exit code is 0.
                - name: Version constant exists
                  inputs: |
                    Inspect cmd/sdd-hello-world/version.go for a Version constant.
                  expected: |
                    The file declares a package-level constant named Version of type string.
                - name: No external dependencies
                  inputs: |
                    Inspect go.mod for require directives.
                  expected: |
                    No require directives exist. The module depends only on the Go standard
                    library.
    analysis:
        consistency_errors: 0
        code_status:
            releases:
                - version: "02.0"
                  name: Hello world binary from specifications
                  specstatus: pending
                  codereadiness: none
                  usecases:
                    - id: rel02.0-uc001-build-hello-world
                      specstatus: pending
                      codestatus: not started
                      testdir: ""
                      testfiles: 0
            gaps: []
    source_code:
        - file: cmd/sdd-hello-world/version.go
          lines: |-
            1 | // Copyright (c) 2026 Petar Djukic. All rights reserved.
            2 | // SPDX-License-Identifier: MIT
            4 | package main
            6 | // Version is set during the generation process.
            7 | const Version = "generation-2026-03-01-17-56-37"
    extra:
        - file: docs/constitutions/design.yaml
          name: design
          content:
            articles:
                - id: D1
                  title: Specification-driven development
                  rule: |
                    Specifications are the source of truth. Code serves specifications, not
                    the other way around. No implementation code before the PRD and use case
                    exist. No implementation issue before a test suite exists for its use case.
                - id: D2
                  title: YAML-first for structured docs
                  rule: |
                    Use YAML for structured documents (VISION, ARCHITECTURE, PRDs, use cases,
                    test suites). Use markdown for prose-heavy guidelines and specifications
                    summaries. YAML is machine-readable by design.
                - id: D3
                  title: Test suite linkage is mandatory
                  rule: |
                    Every use case must have a corresponding test suite. The test suite
                    validates the use case's success criteria with explicit inputs and
                    expected outputs.
                - id: D4
                  title: Traceability
                  rule: |
                    Every PRD traces to VISION and ARCHITECTURE. Every use case traces to
                    PRDs (via touchpoints). Every test suite traces to use cases (via the
                    traces field). Code traces to PRDs via commit messages and comments.
                - id: D5
                  title: Roadmap-driven releases
                  rule: |
                    Use cases are assigned to releases in road-map.yaml. Releases are
                    numbered rel[NN].[N] (e.g., rel01.0, rel02.1). Minor releases validate
                    completed major releases without renumbering existing use cases.
            documentation_standards:
                style: |
                    Write in the style of The Elements of Style by Strunk and White: concise,
                    active voice, specific and concrete language, no unnecessary words.
                voice: |
                    Use the royal "we" in active voice. GOOD: "We implement the feature..."
                    BAD: "This document describes..." or "The architecture implements..."
                forbidden_terms:
                    - critical, critically, key, deliberate, strategic
                    - precisely, absolutely, fundamental, breakthrough
                    - principled, honest, at the heart of, grounded
                    - standards-aligned (unless absolutely necessary)
                formatting:
                    paragraphs: |
                        Use paragraph form unless not possible. Vary sentence length for
                        readability. Use short paragraphs only to emphasize a point. DO NOT use
                        bold text or horizontal rules.
                    lists_and_tables: |
                        Use tables instead of lists for short entries. Name all tables. DO NOT
                        use colons except to introduce lists.
                    abbreviations: |
                        Explain abbreviations at least once per document section. Define
                        domain-specific abbreviations on first use.
                figures_and_diagrams: |
                    All diagrams MUST be written in Mermaid and defined inline in markdown
                    using fenced code blocks. Do not create separate image files.
                    Use centered table format for captioning:
                    ```mermaid
                    graph TD
                        ... diagram source ...
                    ```
            document_types:
                vision:
                    location: docs/VISION.yaml
                    format_rule: vision-format
                    required_fields:
                        - id
                        - title
                        - executive_summary
                        - problem
                        - what_this_does
                        - why_we_build_this
                        - success_criteria
                        - implementation_phases
                        - risks
                        - not (explicit boundaries)
                    purpose: |
                        States what the project is, why it exists, how success is measured, and
                        what it is not. Orients stakeholders, new contributors, and downstream
                        docs (ARCHITECTURE, PRDs).
                architecture:
                    location: docs/ARCHITECTURE.yaml
                    format_rule: architecture-format
                    required_fields:
                        - id
                        - title
                        - overview (summary, lifecycle, coordination_pattern)
                        - interfaces (data_structures, operations, announcements)
                        - components (name, responsibility, capabilities, references)
                        - design_decisions (id, title, decision, benefits, alternatives_rejected)
                        - technology_choices
                        - project_structure
                        - implementation_status
                        - related_documents
                    purpose: |
                        Describes how the system is built: components, interfaces, protocols,
                        data flow, design decisions. Bridge between vision (what and why) and
                        PRDs (numbered requirements).
                prd:
                    location: "docs/specs/product-requirements/prd[NNN]-[feature-name].yaml"
                    format_rule: prd-format
                    required_fields:
                        - id
                        - title
                        - problem (multi-line, why it matters)
                        - goals (G1, G2, ...)
                        - requirements (R1.1, R1.2, ..., grouped by R1, R2, ...)
                        - non_goals
                        - acceptance_criteria
                    numbering:
                        goals: "G1, G2, G3, ..."
                        requirement_groups: "R1, R2, R3, ..."
                        requirement_items: "R1.1, R1.2, R2.1, ..."
                    purpose: |
                        Defines product requirements with numbered goals and requirements. Each
                        requirement starts with "must" or "must not" or a concrete verb. No scope
                        creep - non_goals define explicit boundaries.
                use_case:
                    location: "docs/specs/use-cases/rel[NN].[N]-uc[NNN]-[short-name].yaml"
                    format_rule: use-case-format
                    required_fields:
                        - id
                        - title
                        - summary
                        - actor
                        - trigger
                        - flow (F1, F2, ..., end-to-end steps)
                        - touchpoints (T1, T2, ..., architecture elements exercised)
                        - success_criteria (S1, S2, ..., checkable outcomes)
                        - out_of_scope
                    numbering:
                        flow_steps: "F1, F2, F3, ..."
                        touchpoints: "T1, T2, T3, ..."
                        success_criteria: "S1, S2, S3, ..."
                    purpose: |
                        Describes a concrete usage of the architecture. One end-to-end path
                        (tracer bullet) through the system. Leads to a proof-of-concept or demo.
                        Every use case must be covered by its release test suite.
                test_suite:
                    location: "docs/specs/test-suites/test-rel-[release-id].yaml"
                    format_rule: test-case-format
                    required_fields:
                        - id (matching filename, e.g. test-rel01.0)
                        - title
                        - release (release ID this suite covers)
                        - traces (list of use case IDs covered by this suite)
                        - test_cases (list organized by use case sub-sections, each with name, inputs, expected outputs)
                    purpose: |
                        Groups test cases for a full release. Each use case in the release appears
                        as a sub-section within the suite. The YAML provides quick human/Claude
                        consumption of test coverage; Go tests in tests/rel01.0/ use flat top-level
                        functions named TestRel{NN}_UC{NNN}_DescriptiveName. See
                        docs/constitutions/testing.yaml for the naming convention.
                engineering_guideline:
                    location: "docs/engineering/eng[NN]-[short-name].yaml"
                    format_rule: engineering-guideline-format
                    required_fields:
                        - id
                        - title
                        - introduction (multi-line text)
                        - sections (list with title and content)
                    optional_fields:
                        - references
                    purpose: |
                        Documents conventions, practices, and patterns above the code and
                        architecture. Not PRDs (no numbered requirements). Not architecture (no
                        component descriptions).
                specification:
                    location: docs/SPECIFICATIONS.yaml
                    format_rule: specification-format
                    required_fields:
                        - id
                        - title
                        - overview (multi-line text)
                        - "roadmap_summary (list: version, name, use_cases_done, use_cases_total, status)"
                        - "prd_index (list: id, title, summary, path)"
                        - "use_case_index (list: id, title, release, status, test_suite, path)"
                        - "test_suite_index (list: id, title, traces, test_case_count, path)"
                        - "prd_to_use_case_mapping (list: use_case, prd, why_required, coverage)"
                        - coverage_gaps (list or multi-line text)
                    optional_fields:
                        - traceability_diagram (Mermaid as multi-line string)
                        - references
                    purpose: |
                        Human-readable summary tying together PRDs, use cases, test suites, and
                        roadmap into one navigable page. Does not duplicate content; summarizes
                        and shows relationships. Regenerate when any artifact changes.
                roadmap:
                    location: docs/road-map.yaml
                    purpose: |
                        Defines releases with version, name, focus, and list of use cases with
                        status. Use cases are assigned to releases. Release numbering: rel[NN].[N]
                        (major.minor). Minor releases validate completed major releases.
            naming_conventions:
                prd: "prd[NNN]-[feature-name].yaml (e.g., prd001-hello-world-binary.yaml)"
                use_case: "rel[NN].[N]-uc[NNN]-[short-name].yaml (e.g., rel02.0-uc001-build-hello-world.yaml)"
                test_suite: "test-[use-case-id].yaml (e.g., test-rel02.0-uc001-build-hello-world.yaml)"
                engineering_guideline: "eng[NN]-[short-name].yaml (e.g., eng01-git-integration.yaml)"
                architecture: "ARCHITECTURE.yaml"
                vision: "VISION.yaml"
                specification: "SPECIFICATIONS.yaml"
            writing_guidelines:
                audience: Developers, agents, reviewers. Assume readers need to build or extend the system.
                tone: "Use 'we' in active voice. Follow documentation-standards: concise, active voice, no forbidden terms."
                scope: Describe structure and contracts; do not duplicate. Point to upstream docs for detail.
                tables: Name all tables per documentation-standards.
                figures: Per documentation-standards. Define Mermaid inline; do not create separate image files.
            traceability_model:
                vision: Goals and boundaries
                architecture: Components and interfaces (implements vision)
                prds: Numbered requirements (architecture points to PRDs for detail)
                use_cases: Tracer bullets (exercise architecture components via touchpoints)
                test_suites: Validation (validate use case success criteria)
                code: Implementation (traces to PRDs via commit messages)
            completeness_checklists:
                vision:
                    - id matches project name
                    - executive_summary states what the project is and what it is not
                    - problem covers context, why current solutions fall short, what this does differently
                    - success_criteria covers meaningful dimensions
                    - implementation_phases lists phases with focus and deliverables
                    - risks lists known risks with impact, likelihood, mitigation
                    - not lists explicit boundaries
                    - File saved as VISION.yaml in docs/
                architecture:
                    - id matches project name
                    - overview.summary states what the system does and core insight
                    - interfaces list data structures, operations, announcements; link to PRD for full spec
                    - components list each major component with responsibility; link to PRD or use case
                    - design_decisions are numbered with decision statement and benefits
                    - project_structure shows directory paths and roles
                    - File saved as ARCHITECTURE.yaml in docs/
                prd:
                    - id matches filename without extension
                    - problem states what we solve and why it matters
                    - goals are numbered (G1, G2, ...) and measurable
                    - requirements are grouped (R1, R2, ...) with numbered items (R1.1, R1.2, ...)
                    - Each requirement is specific and actionable
                    - non_goals define what is out of scope
                    - acceptance_criteria are checkable without ambiguity
                    - File saved as prd[NNN]-[feature-name].yaml
                use_case:
                    - id matches filename without extension
                    - flow steps are numbered (F1, F2, ...), end-to-end, map to real components
                    - touchpoints are numbered (T1, T2, ...) and list interfaces, components, protocols
                    - success_criteria are numbered (S1, S2, ...) and checkable without ambiguity
                    - test_suite references a corresponding test suite ID
                    - Test suite YAML exists and traces back to this use case
                    - Use case added to appropriate release in road-map.yaml
                    - File saved as rel[NN].[N]-uc[NNN]-[short-name].yaml
                test_suite:
                    - id matches filename
                    - traces lists at least one use case or PRD requirement
                    - preconditions describe shared starting state
                    - Each test case has name, inputs, expected outputs
                    - Inputs use real commands and data
                    - Expected outputs are specific and checkable
                    - File saved as test-[use-case-id].yaml
            sections:
                - tag: articles
                  title: Core Principles
                  content: |
                    Five principles govern the design phase: specifications are the source of
                    truth, YAML is the format for structured documents, every use case must
                    link to a test suite, all artifacts trace through a chain from vision to
                    code, and releases are roadmap-driven.
                - tag: documentation_standards
                  title: Documentation Standards
                  content: |
                    Write in the style of Strunk and White: concise, active voice, specific,
                    no unnecessary words. Use the royal "we." Tables over lists for short
                    entries. Avoid forbidden terms such as "critical," "key," and "strategic."
                - tag: document_types
                  title: Document Types
                  content: |
                    Seven document types are defined: vision, architecture, PRD, use case,
                    test suite, engineering guideline, and specification. Each has a canonical
                    location, format rule, required fields, and optional fields.
                - tag: naming_conventions
                  title: Naming Conventions
                  content: |
                    File names follow strict patterns per document type (e.g.,
                    prd[NNN]-[feature].yaml, rel[NN].[N]-uc[NNN]-[name].yaml). Use lowercase
                    kebab-case throughout.
                - tag: writing_guidelines
                  title: Writing Guidelines
                  content: |
                    Write for developers, agents, and reviewers. Describe structure and
                    contracts; point to upstream docs for detail. Use "we" in active voice and
                    present tense.
                - tag: traceability_model
                  title: Traceability Model
                  content: |
                    Every artifact traces through the chain: vision goals → architecture
                    components → PRD requirements → use case tracer bullets → test suite
                    validation → code implementation.
                - tag: completeness_checklists
                  title: Completeness Checklists
                  content: |
                    Each document type has a checklist of required fields and cross-references
                    to verify before closing an issue. Run mage analyze to catch missing
                    linkages automatically.
        - file: docs/constitutions/execution.yaml
          name: execution
          content:
            articles:
                - id: E1
                  title: Specification-first
                  rule: |
                    Code must correspond to existing PRDs and architecture. Read the PRDs and
                    ARCHITECTURE sections listed in Required Reading before writing code. Do
                    not invent interfaces, types, or patterns not described in those docs.
                - id: E2
                  title: Traceability
                  rule: |
                    Commit messages must mention which PRDs (or aspects) are implemented.
                    Example: "Implement X (prd-feature-name R6-R7)". Where useful (package or
                    top-of-file comments), list the implemented PRDs.
                - id: E3
                  title: No scope creep
                  rule: |
                    Do NOT modify files outside the Files to Create/Modify list unless a
                    requirement explicitly demands it. Do NOT add features, refactoring, or
                    improvements beyond what the requirements specify. Complete the task as
                    scoped, nothing more.
                - id: E4
                  title: Session completion
                  rule: |
                    Work is complete when all files are written and tests pass. Do NOT run
                    any git commands. Git operations (add, commit, status, init) are handled
                    externally by the orchestrator.
                - id: E5
                  title: Quality gates
                  rule: |
                    Every item in Acceptance Criteria must be verified. Run tests if the
                    criteria require it. Do not skip any criterion.
            coding_standards:
                copyright_header: |
                    Every Go file must start with the SPDX copyright header:
                    // Copyright (c) 2026 Petar Djukic. All rights reserved.
                    // SPDX-License-Identifier: MIT
                never_duplicate_code: |
                    Before writing a function, search for existing code that does the same thing.
                    When two pieces of code share logic, extract the common part. The threshold
                    is two: if you write the same thing twice, extract it.
                design_patterns:
                    - Strategy: Multiple implementations, caller picks one. Define interface, not if/else ladder.
                    - Command: Encapsulate actions for queuing, undo, or composition.
                    - Facade: Simplified interface to complex subsystem. No toggle parameters.
                    - Factory: Centralized construction via NewXxx() functions.
                    - Decorator: Add cross-cutting concerns (logging, timing) without modifying the wrapped object.
                    - Adapter: Interface translation for foreign APIs.
                interfaces: |
                    Introduce an interface when you have two concrete implementations or when
                    you need to mock a dependency in tests. Do not create an interface for a
                    single implementation "just in case." Accept interfaces as parameters;
                    return concrete structs. Keep interfaces small: one to three methods.
                struct_and_function_design: |
                    Each struct represents one concept. Each function does one thing. If a
                    function takes more than three parameters, group related parameters into a
                    config struct. If a function exceeds 40 lines, find a seam and split it.
                error_handling: |
                    Handle errors at the point they occur. Use guard clauses: check err != nil
                    and return early. Wrap errors with context: fmt.Errorf("doing X: %w", err).
                    Never silently discard an error with _ unless the operation is best-effort
                    cleanup (e.g., removing a temp file). When discarding, leave a comment.
                no_magic_strings: |
                    Centralize all string literals that name external binaries, file paths,
                    URLs, or repeated text. Binary names: const (e.g., binGit, binGo). Large
                    prompts: embedded .tmpl templates. Never scatter raw string literals.
                project_structure: |
                    cmd/: Entry points. Minimal: parse flags, wire dependencies, start.
                    internal/: Private implementation. Not importable outside this module.
                    pkg/: Shared public types and interfaces. No implementation.
                    tests/: Integration tests.
                    magefiles/: Build tooling. Flat directory. One file per concern.

                    Align package structure to PRD component structure. Each major component
                    maps to one package. Avoid package names like util, common, helpers.
                standard_packages:
                    - "Build automation: magefile/mage"
                    - "CLI framework: spf13/cobra"
                    - "Configuration: spf13/viper"
                    - "Testing assertions: stretchr/testify"
                    - "YAML parsing: gopkg.in/yaml.v3"
                    - "JSON handling: encoding/json (stdlib)"
                naming_conventions:
                    exported: PascalCase (e.g., ProjectConfig)
                    unexported: camelCase (e.g., cobblerConfig)
                    cli_flags: kebab-case (e.g., --silence-agent)
                    binary_constants: "bin prefix + PascalCase (e.g., binGit, binClaude)"
                    factories: "New prefix (e.g., NewBackend())"
                    interfaces: "Action or capability (e.g., Table, Reader)"
                concurrency: |
                    Pass context.Context as the first parameter to any function that does I/O
                    or may block. Never start a goroutine without a plan for how it exits. Use
                    sync.WaitGroup or a done channel to manage lifetimes.
                testing: |
                    Every exported function and every meaningful branch deserves a test. Use
                    table-driven parameterized tests for similar cases. Extract shared setup
                    into test helpers. Build reusable test utilities in a testutil package.
            traceability:
                before_implementing:
                    - Identify related PRDs, ARCHITECTURE, use cases, test suites, guidelines, VISION
                    - Read the relevant sections so behavior, data shapes, and contracts are clear
                    - Implement so the code conforms to the requirements and design described
                commit_message: |
                    Must mention which PRDs (or aspects) are being implemented. Prefer explicit:
                    "Implement X (prd-feature-name, prd-component)" or "Add Y per prd-feature R12".
                    If only parts touched, say so: "Implement operation X (prd-feature R8, R13)".
                code_comments: |
                    At the top of a file or package doc, list implemented PRDs and architecture
                    sections. Do not repeat this in every function; use file- or package-level
                    comments only.
                reference_paths:
                    - "Architecture: docs/ARCHITECTURE.yaml"
                    - "PRDs: docs/specs/product-requirements/prd*.yaml"
                    - "Use cases: docs/specs/use-cases/rel*-uc*-*.yaml"
                    - "Test suites (YAML specs): docs/specs/test-suites/test-rel-*.yaml"
                    - "Release tests (Go): tests/rel-*/rel-*_test.go"
                    - "Engineering guidelines: docs/engineering/eng*.md"
                    - "Vision: docs/VISION.yaml"
            session_completion:
                git_managed_externally: true # Do NOT run any git commands
                token_tracking: true # Log tokens used per issue
                workflow:
                    - Run quality gates if code changed (tests, linters, builds)
                    - Ensure all files are written and saved
                    - Verify code compiles and tests pass
                critical_rules:
                    - Do NOT run any git commands (add, commit, status, init, rm .git)
                    - Git is managed externally by the orchestrator
                    - Your job is to write code and verify it works
                    - Do NOT interact with the issue tracker directly; GitHub Issues are managed by the orchestrator
            technology:
                primary_language: Go
                python_manager: pixi # Use pixi for Python, not pip/pip3 directly
                cli_framework: cobra
                build_system: mage
                yaml_library: gopkg.in/yaml.v3
                issue_tracker: github-issues
            git_conventions:
                note: Git is managed externally. Do NOT run any git commands.
            sections:
                - tag: articles
                  title: Core Principles
                  content: |
                    Six principles govern the stitch phase: specification-first development,
                    commit traceability, no scope creep, session completion via
                    orchestrator-managed git, quality gate enforcement, and prohibition of
                    magic test values.
                - tag: coding_standards
                  title: Coding Standards
                  content: |
                    Go code follows the project's style guide: typed error handling, no magic
                    strings, one concept per struct, and design patterns applied to eliminate
                    conditional branching. Interfaces are introduced only when two concrete
                    implementations exist.
                - tag: traceability
                  title: Traceability
                  content: |
                    Before implementing, read the specified PRDs and architecture sections.
                    Commit messages must cite PRDs. Add a PRD list to file or package comments
                    where useful.
                - tag: session_completion
                  title: Session Completion
                  content: |
                    Work is complete when all files are written and tests pass. Git operations
                    are managed externally by the orchestrator; do not run any git commands.
                - tag: technology
                  title: Technology Stack
                  content: |
                    The project uses Go with mage for build automation, cobra for CLI, viper
                    for configuration, yaml.v3 for YAML parsing, and GitHub Issues for task
                    tracking.
                - tag: git_conventions
                  title: Git Conventions
                  content: |
                    Git is managed externally. Do not run any git commands during a stitch
                    session; the orchestrator handles all staging, committing, and branching.
        - file: docs/constitutions/go-style.yaml
          name: go-style
          content:
            copyright_header: |
                Every Go file must start with the SPDX copyright header before the package
                declaration:

                  // Copyright (c) 2026 Petar Djukic. All rights reserved.
                  // SPDX-License-Identifier: MIT

                This applies to hand-written files (magefiles/) and generated files (cmd/,
                pkg/, internal/, tests/). The header must appear on lines 1-2, followed by a
                blank line, then the package clause.
            duplication: |
                Before writing a function, search for existing code that does the same thing.
                Before adding a field, check whether a struct already carries it. When two
                pieces of code share logic, extract the common part. Use struct embedding to
                share fields. Use helper functions to share behavior. Use interfaces to share
                contracts. The threshold is two: if you write the same thing twice, extract it.
            design_patterns:
                - name: Strategy
                  description: |
                    Use when multiple implementations of the same operation exist and the
                    caller picks one. Define a small interface. Each implementation is a struct
                    (or a function type) satisfying that interface. The caller selects at
                    configuration time, not with if chains.
                  symptoms: |
                    A switch or if/else ladder choosing between behaviors, a function parameter
                    named mode or kind, boolean flags that toggle logic branches.
                - name: Command
                  description: |
                    Use when an action needs to be stored, queued, undone, or composed. Each
                    command is a struct with an Execute() method. Commands can carry undo logic,
                    be chained into sequences, or be logged for replay.
                  symptoms: |
                    Inline exec.Command calls scattered across a function, repeated sequences of
                    shell operations that differ only in arguments, actions that should be
                    retryable or reversible.
                - name: Facade
                  description: |
                    Use when a caller should not know about the internal steps of a multi-step
                    process. The facade exposes one method; internally it orchestrates several
                    components. Do not add toggle parameters to a facade. If the caller needs to
                    control sub-steps, they should use the components directly.
                  symptoms: |
                    A function that grew boolean parameters to skip internal steps, a caller that
                    must call three functions in a specific order, an Init/Do/Cleanup pattern that
                    keeps getting duplicated.
                - name: Factory
                  description: |
                    Use NewXxx() functions to construct objects. Return concrete types but accept
                    interfaces as dependencies. Factories centralize validation and wiring so
                    callers never construct partially initialized structs.
                - name: Decorator
                  description: |
                    Use to add cross-cutting concerns (logging, timing, retries) without
                    modifying the wrapped object. In Go, the decorator accepts and returns the
                    same interface. HTTP middleware is the canonical example.
                  symptoms: |
                    Logging or timing code copy-pasted around every call to an interface, optional
                    behavior toggled by a boolean that wraps the real logic.
                - name: Builder
                  description: |
                    Use when an object has many optional fields and constructing it in one call is
                    unwieldy. Prefer the Functional Options variant (WithXxx functions) for
                    idiomatic Go over a mutable builder struct.
                - name: Adapter
                  description: |
                    Use when existing code does not satisfy the interface a consumer expects.
                    Write a thin wrapper that translates the foreign API into the local interface.
                    Do not modify the foreign code.
                - name: Observer
                  description: |
                    Use channels for asynchronous event notification between goroutines. One
                    producer writes to a channel; multiple consumers listen. Prefer this over
                    callback registration when the producer should not know about its consumers.
            interfaces: |
                Introduce an interface when you have two concrete implementations or when you
                need to mock a dependency in tests. Do not create an interface for a single
                implementation "just in case." Accept interfaces as parameters; return concrete
                structs. Keep interfaces small: one to three methods. A large interface is a
                sign that the abstraction is wrong. Split it into focused interfaces and compose
                them.

                Do not use interface{} or any as function parameters, return types, or struct
                fields. Every value must have a concrete type or a named interface. If a
                function needs to accept multiple types, define an interface that captures the
                shared behavior, or use generics with type constraints. Type assertions and
                type switches on interface{}/any are symptoms of a missing abstraction. The
                only acceptable uses are stdlib boundaries that require it (e.g., json.Marshal,
                fmt.Sprintf variadic args).
            struct_and_function_design: |
                Each struct represents one concept. Each function does one thing. If a function
                takes more than three parameters, group related parameters into a config struct.
                If a function exceeds 200 lines, find a seam and split it. Name structs and
                functions by what they represent or do, not by how they are called. Avoid
                generic names (Manager, Handler, Helper, Processor) unless the struct genuinely
                manages, handles, or processes a well-defined resource.
            error_handling: |
                Handle errors at the point they occur. Use guard clauses: check err != nil and
                return early so the main logic stays at minimal indentation. Wrap errors with
                context: fmt.Errorf("doing X: %w", err). Each wrap adds the "why" at that
                layer, producing a readable chain when the error surfaces. Never silently
                discard an error with _ unless the operation is best-effort cleanup (e.g.,
                removing a temp file after the real work succeeded). When discarding, leave a
                comment explaining why.
            no_magic_strings: |
                Centralize all string literals that name external binaries, file paths, URLs,
                or repeated text. Binary names: const (e.g., binGit, binGo). Paths, prefixes,
                module names: const. Shared CLI arg slices: var. Large prompts with variable
                interpolation: embedded .tmpl templates. Short messages with interpolation:
                fmt.Sprintf at the call site. Static messages or labels: const. When adding a
                new external command or path, define the constant first, then use it. Never
                scatter raw string literals across files.
            project_structure: |
                cmd/: Entry points. Minimal: parse flags, wire dependencies, start.
                internal/: Private implementation. Not importable outside this module. One
                package per component.
                pkg/: Shared public types and interfaces. No implementation. The contract layer
                between libraries.
                tests/: Integration tests.
                magefiles/: Build tooling. Flat directory (mage constraint). One file per
                concern.

                Align package structure to PRD component structure. Each major component maps
                to one package. Avoid package names like util, common, helpers. Name packages
                by domain: storage, auth, config.

                Define interfaces between major components. The pkg/ directory holds shared
                types and interface contracts. The internal/ directory holds implementations
                that satisfy those contracts.
            standard_packages:
                - "Build automation: magefile/mage"
                - "CLI framework: spf13/cobra"
                - "Configuration: spf13/viper"
                - "Observability: go.opentelemetry.io/otel"
                - "Testing assertions: stretchr/testify"
                - "SQL database access: database/sql (stdlib) + mattn/go-sqlite3"
                - "HTTP routing: net/http (stdlib) or chi"
                - "YAML parsing: gopkg.in/yaml.v3"
                - "JSON handling: encoding/json (stdlib)"
                - "UUID generation: google/uuid"
            struct_embedding: |
                When two or more consumers share configuration fields, extract a common struct
                and embed it. Provide a registerXxxFlags helper when the shared fields map to
                CLI flags. Do not duplicate fields across sibling structs.
            naming_conventions:
                - "Exported types and functions: PascalCase (e.g., ProjectConfig)"
                - "Unexported types and functions: camelCase (e.g., cobblerConfig)"
                - "CLI flags: kebab-case (e.g., --silence-agent)"
                - "Constants for binaries: bin prefix + PascalCase (e.g., binGit, binClaude)"
                - "Factory functions: New prefix (e.g., NewBackend())"
                - "Interface names: Action or capability (e.g., Table, Reader)"
            concurrency: |
                Pass context.Context as the first parameter to any function that does I/O or
                may block. Never start a goroutine without a plan for how it exits. Use
                sync.WaitGroup or a done channel to manage lifetimes.
            testing: |
                Every exported function and every meaningful branch deserves a test. Use
                table-driven parameterized tests for similar cases. Each row is one scenario
                with named inputs and expected outputs. Extract shared setup into test helpers.
                Build reusable test utilities in a testutil package. When writing tests, ask
                what inputs break assumptions: zero values, nil pointers, empty slices,
                duplicate keys, boundary lengths, concurrent access. If a bug could hide there,
                write a case for it.
            code_review_checklist:
                - "No duplicated logic exists that could be extracted into a shared function or struct."
                - "No magic strings remain: all binaries, paths, and repeated text are centralized."
                - "Every error is handled or explicitly discarded with a comment."
                - "Every struct has a single, nameable responsibility."
                - "No function exceeds 200 lines without a strong reason."
                - "Interfaces are small (one to three methods) and have at least two implementations or a testing need."
                - "No boolean parameters toggle behavior that should be a Strategy or Decorator."
                - "Config structs embed shared fields rather than duplicating them."
                - "context.Context is threaded through I/O paths."
                - "Tests cover the contract, not the implementation."
            sections:
                - tag: copyright_header
                  title: Copyright Header
                  content: |
                    Every Go file must begin with the SPDX copyright header line.
                - tag: duplication
                  title: Code Duplication
                  content: |
                    Search for existing code before writing a new function. Extract shared
                    logic at the two-occurrence threshold — if you write the same thing twice,
                    extract it.
                - tag: design_patterns
                  title: Design Patterns
                  content: |
                    Six patterns apply: Strategy, Command, Facade, Factory, Decorator, and
                    Adapter. Select patterns to eliminate if/else ladders and centralize
                    construction logic.
                - tag: interfaces
                  title: Interfaces
                  content: |
                    Introduce an interface only when two concrete implementations exist or a
                    dependency must be mocked in tests. Accept interfaces as parameters;
                    return concrete structs. Keep interfaces small: one to three methods.
                - tag: struct_and_function_design
                  title: Struct and Function Design
                  content: |
                    Each struct represents one concept; each function does one thing. Group
                    more than three parameters into a config struct. Split functions exceeding
                    40 lines at a natural seam.
                - tag: error_handling
                  title: Error Handling
                  content: |
                    Handle errors at the point they occur with guard clauses. Wrap errors with
                    context using fmt.Errorf. Never silently discard an error except for
                    best-effort cleanup, and always leave a comment when discarding.
                - tag: no_magic_strings
                  title: No Magic Strings
                  content: |
                    Centralize all string literals for binary names, file paths, URLs, and
                    repeated text as named constants. Never scatter raw string literals.
                - tag: project_structure
                  title: Project Structure
                  content: |
                    cmd/ for entry points, internal/ for private implementation, pkg/ for
                    public shared types, tests/ for integration tests, magefiles/ for build
                    tooling. Align package structure to PRD component structure.
                - tag: standard_packages
                  title: Standard Packages
                  content: |
                    Approved dependencies: mage for build automation, cobra for CLI, viper for
                    configuration, testify for test assertions, yaml.v3 for YAML parsing, and
                    encoding/json from the standard library.
                - tag: naming_conventions
                  title: Naming Conventions
                  content: |
                    Exported names use CamelCase; unexported use camelCase. CLI flags use
                    kebab-case. Binary constants use the binXxx prefix. Factories use NewXxx.
                    Interfaces are named to describe behavior, not implementation.
                - tag: concurrency
                  title: Concurrency
                  content: |
                    Use sync.Mutex for shared mutable state. Avoid global variables accessed
                    from goroutines. Thread context.Context through all I/O paths.
                - tag: testing
                  title: Testing
                  content: |
                    Write table-driven tests using t.Run subtests. Use testify assertions.
                    Mock external dependencies via interfaces. Tests cover contract, not
                    implementation; include edge cases, boundary lengths, and concurrent access.
                - tag: code_review_checklist
                  title: Code Review Checklist
                  content: |
                    Before closing, verify: no duplicated logic, no magic strings, every error
                    handled or discarded with a comment, single-responsibility structs,
                    functions under 200 lines, small interfaces with at least two
                    implementations, no boolean-toggle parameters, and tests covering the
                    contract.
        - file: docs/constitutions/planning.yaml
          name: planning
          content:
            articles:
                - id: P1
                  title: Release-driven priority
                  rule: |
                    Focus on the earliest incomplete release from road-map.yaml. Every issue
                    should map to a use case in the roadmap. If uncertain, assign to release
                    99.0 (unscheduled). Early preview of later use cases is allowed when they
                    share functionality with the current release.
                - id: P2
                  title: Task sizing
                  rule: |
                    Code tasks should target the line range specified in the CONSTRAINTS
                    section of the prompt (typically 250-350 lines of production code),
                    touching no more than 5-7 files. Split larger features into multiple
                    tasks. Combine trivial changes into one task.

                    Always split implementation and tests into separate tasks. Decompose
                    each feature into up to three tasks in this order: (1) types and
                    interfaces, (2) implementation, (3) tests. A single task must never
                    both implement and test the same feature. If the types and interfaces
                    are small enough to fit within the implementation task's line budget,
                    combine steps 1 and 2 into one task.

                    Each task must be completable within the Claude timeout (typically
                    5-10 minutes). If a task would require more than 20 agent turns, it
                    is too large and must be split further. Treat timeout as a signal
                    that the task needs decomposition, not retrying.
                - id: P3
                  title: Task limit per batch
                  rule: |
                    Create no more than 10 tasks at a time. If more work is needed, create
                    additional tasks after completing some of the current batch.
                - id: P4
                  title: Issue structure
                  rule: |
                    Every issue description must be a YAML document with: deliverable_type
                    (documentation or code), required_reading (mandatory), files (explicit
                    paths with action: create or modify), requirements, acceptance_criteria.
                    Documentation issues also include format_rule and required_sections.
                - id: P5
                  title: Dependency ordering
                  rule: |
                    Identify what should be built first and why. PRDs before use cases,
                    use cases before test suites, test suites before code, foundational code
                    before features, libraries before CLI.
                - id: P6
                  title: Requirement-anchored decomposition
                  rule: |
                    Anchor each task to specific PRD requirements by ID (e.g., prd001 R1.1,
                    prd002 R2.3). Include the requirement ID(s) in the task title. Each PRD
                    requirement maps to exactly one task unless the requirement exceeds the
                    line budget, in which case split into implementation and test tasks that
                    both reference the same requirement. Do not invent task boundaries that
                    cross requirement boundaries. This makes decomposition deterministic:
                    given the same PRD and release, the same set of tasks should be proposed.
                - id: P7
                  title: File naming conventions
                  rule: |
                    Derive file names from the module or feature name established in the
                    PRD or architecture document. Use the existing project naming pattern
                    (snake_case for Go files, kebab-case for YAML documents). When creating
                    a new package, use the name from ARCHITECTURE.yaml. Do not invent novel
                    file names. If the PRD names a component "crumb", the file is crumb.go,
                    not item.go or entity.go. Go packages must name the primary source file
                    after the primary exported type, not the package name.
                    `testutils/testutils.go` is forbidden; if the primary type is
                    `DiffTest`, the file is `difftest.go`. Test files mirror source:
                    `difftest_test.go`.
                - id: P8
                  title: Deterministic ordering
                  rule: |
                    Propose tasks in a fixed canonical order. Within the same release:
                    1. Documentation tasks before code tasks.
                    2. Types and interfaces before implementations.
                    3. Libraries and shared packages before consumers.
                    4. Implementation before tests (when split into separate tasks).
                    When two tasks have equal priority under these rules, order by the
                    primary file path alphabetically. This ensures the same input produces
                    the same task sequence.
                - id: P9
                  title: Requirement granularity
                  rule: |
                    Code tasks target 5-8 requirements, 5-8 acceptance criteria, and 3-5
                    design decisions. Documentation tasks target 2-4 requirements and 3-5
                    acceptance criteria. Each PRD requirement maps to exactly one task
                    requirement. Do not inflate counts by splitting a single requirement
                    into sub-bullets, and do not deflate counts by merging unrelated
                    requirements. If a task falls outside these ranges, re-examine the
                    decomposition.
            issue_structure:
                common_fields:
                    deliverable_type:
                        required: true
                        values: [documentation, code]
                        description: What kind of deliverable this issue produces
                    required_reading:
                        required: true
                        description: |
                            Files the agent must read before starting. List PRDs, ARCHITECTURE
                            sections, existing code, or upstream docs. This is mandatory for all
                            issues.
                    files:
                        required: true
                        description: |
                            Explicit list of files the issue will produce or change. Each entry
                            has path (absolute from repo root), action (create or modify), and
                            optional note (purpose).
                    requirements:
                        required: true
                        description: |
                            What needs to be built or written. Each item is a mapping with
                            `id` (R1, R2, ...) and `text` fields. Be specific and actionable.
                    design_decisions:
                        required: false
                        description: |
                            Architecture, patterns, or constraints to follow. Each item is a
                            mapping with `id` (D1, D2, ...) and `text` fields. Optional but
                            recommended for code tasks.
                    acceptance_criteria:
                        required: true
                        description: |
                            Checkable outcomes. Each item is a mapping with `id` (AC1, AC2, ...)
                            and `text` fields. Must be verifiable without ambiguity.
                documentation_issues:
                    additional_fields:
                        format_rule:
                            required: true
                            description: |
                                The rule file that governs the output format (e.g., prd-format,
                                use-case-format, test-case-format, architecture-format,
                                vision-format, specification-format, engineering-guideline-format).
                        required_sections:
                            required: false
                            description: |
                                List of sections the document must contain, per the format rule.
                                For PRD: Problem, Goals, Requirements, Non-Goals, Acceptance Criteria.
                                For use case: Summary, Actor/trigger, Flow, Success criteria.
                    deliverable_types:
                        - type: ARCHITECTURE
                          location: docs/ARCHITECTURE.yaml
                          format_rule: architecture-format
                          when: Updating system overview, components, design decisions
                        - type: PRD
                          location: "docs/specs/product-requirements/prd[NNN]-[feature-name].yaml"
                          format_rule: prd-format
                          when: New or updated product requirements
                        - type: Use case
                          location: "docs/specs/use-cases/rel[NN].[N]-uc[NNN]-[short-name].yaml"
                          format_rule: use-case-format
                          when: Tracer-bullet flows, actor/trigger, demo criteria
                        - type: Test suite
                          location: "docs/specs/test-suites/test-rel-[release-id].yaml"
                          format_rule: test-case-format
                          when: Release-level test coverage spec; use cases as sub-sections
                        - type: Engineering guideline
                          location: "docs/engineering/eng[NN]-[short-name].md"
                          format_rule: engineering-guideline-format
                          when: Conventions and practices
                        - type: Specification
                          location: docs/SPECIFICATIONS.md
                          format_rule: specification-format
                          when: Summary of PRDs, use cases, test suites, roadmap
                yaml_quality:
                    - Use ASCII dashes (--), not Unicode em dashes or en dashes.
                    - Requirements, design decisions, and acceptance criteria are all mappings with id and text fields.
                code_issues:
                    rules:
                        - No PRD-style Problem/Goals/Non-Goals sections in code issues
                        - "Requirements focus on implementation: interfaces, operations, tests"
                        - Design decisions reference PRDs and architecture patterns
                        - Acceptance criteria include tests passing and behavior verified
            example_documentation_issue: |
                deliverable_type: documentation
                format_rule: prd-format

                required_reading:
                  - docs/ARCHITECTURE.yaml (components section)
                  - docs/specs/product-requirements/prd001-hello-world-binary.yaml

                files:
                  - path: docs/specs/product-requirements/prd-feature-name.yaml
                    action: create

                required_sections:
                  - "Problem: explain the problem and why it matters"
                  - "Goals: G1 ..., G2 ..."
                  - "Requirements: R1.1 ..., R1.2 ..."
                  - "Non-Goals: what is out of scope"
                  - "Acceptance Criteria: checkable outcomes"

                acceptance_criteria:
                  - id: AC1
                    text: All required sections present
                  - id: AC2
                    text: File saved as prd-feature-name.yaml
                  - id: AC3
                    text: Requirements numbered and specific
            example_code_issue: |
                deliverable_type: code

                required_reading:
                  - docs/specs/product-requirements/prd003-crumbs-interface.yaml
                  - cmd/sdd-hello-world/main.go

                files:
                  - path: pkg/types/crumb.go
                    action: create
                    note: Crumb struct, Filter type
                  - path: internal/sqlite/crumbs.go
                    action: create
                    note: CrumbTable implementation
                  - path: internal/sqlite/crumbs_test.go
                    action: create
                    note: tests

                requirements:
                  - id: R1
                    text: Implement CrumbTable interface per prd003-crumbs-interface
                  - id: R2
                    text: Add, Get, Archive, Purge, Fetch operations
                  - id: R3
                    text: Property operations (Set/Get/Clear)

                design_decisions:
                  - id: D1
                    text: Follow binary structure from prd001-hello-world-binary
                  - id: D2
                    text: Filter as map[string]any per PRD

                acceptance_criteria:
                  - id: AC1
                    text: All CrumbTable operations implemented
                  - id: AC2
                    text: Tests pass for each operation
                  - id: AC3
                    text: Errors match PRD error types
            sections:
                - tag: articles
                  title: Core Principles
                  content: |
                    Three principles govern the planning phase: decompose work to fit within
                    one session, write specifications before code, and never create
                    implementation issues without an existing test suite for the use case.
                - tag: issue_structure
                  title: Issue Structure
                  content: |
                    All issues share five common fields: deliverable_type, required_reading,
                    files, requirements, and acceptance_criteria. Documentation issues add
                    format_rule and required_sections. Code issues specify files to modify
                    with explicit actions and size constraints.
                - tag: example_documentation_issue
                  title: Documentation Issue Example
                  content: |
                    A worked example shows a properly structured documentation issue for
                    writing a PRD, including required reading, output path, format rule, and
                    acceptance criteria.
                - tag: example_code_issue
                  title: Code Issue Example
                  content: |
                    A worked example shows a properly structured code issue for implementing a
                    feature, including required reading, files to create or modify,
                    requirements with IDs, and acceptance criteria.
        - file: docs/constitutions/testing.yaml
          name: testing
          content:
            articles:
                - id: T1
                  title: Hierarchical test naming
                  rule: |
                    Encode the test suite and use case into every test function name using
                    a fixed prefix: Test{Suite}_UC{NNN}_DescriptiveName.

                    {Suite} identifies the test suite (e.g., Rel01, Alpha, Smoke).
                    UC{NNN} is the zero-padded use case number from the spec.
                    DescriptiveName is CamelCase and describes the behavior under test
                    in action-outcome form (e.g., CreateReturnsID, StartFailsWhenLocked).

                    The prefix hierarchy enables filtering at any granularity:

                      go test -run TestRel01             # entire suite
                      go test -run TestRel01_UC003       # one use case
                      go test -run TestRel01_UC003_Create  # one test
                - id: T2
                  title: One file per use case
                  rule: |
                    Group tests into one file per use case, named uc{NNN}_{slug}_test.go.
                    Shared test infrastructure (setup, helpers, TestMain) lives in a
                    dedicated helpers file (e.g., helpers_test.go). Do not mix tests from
                    different use cases in the same file.
                - id: T3
                  title: Spec-to-code traceability
                  rule: |
                    Every test case entry in the test suite spec must reference the test
                    function that implements it. Every test function must appear in the
                    spec. No orphans in either direction.

                    When one test function covers multiple spec entries, each entry
                    references the same function. The entry with the closest name match
                    is the primary; others note the shared coverage.
                - id: T4
                  title: Test count invariant
                  rule: |
                    The number of test functions in a suite must be greater than or equal
                    to the number of test case entries in the corresponding spec. Tests
                    may exceed the spec count (edge cases, performance tests) but must
                    never fall below it. Reorganizing tests must not reduce the total.
                - id: T5
                  title: Mage target naming
                  rule: |
                    Expose each use case as a mage target under the Test namespace:

                      (Test) Uc{NNN}{UseCaseSlug}()

                    {NNN} is the zero-padded use case number. {UseCaseSlug} is the
                    CamelCase form of the use case slug from the spec (e.g.,
                    OrchestratorInitialization, MeasureWorkflow, BuildTooling).

                    Additionally provide test:usecase (all use-case tests), test:unit (package
                    tests), and test:all (both). Examples:

                      mage test:uc001OrchestratorInitialization
                      mage test:uc003MeasureWorkflow
                      mage test:usecase
            sections:
                - tag: articles
                  title: Testing Principles
                  content: |
                    Five principles govern the testing phase: hierarchical test naming
                    (Test{Suite}_UC{NNN}_DescriptiveName), one file per use case,
                    bidirectional spec-to-code traceability, a test count invariant that
                    never allows fewer tests than spec entries, and mage test:uc{NNN} targets
                    for each use case.
planning_constitution:
    articles:
        - id: P1
          title: Release-driven priority
          rule: |
            Focus on the earliest incomplete release from road-map.yaml. Every issue
            should map to a use case in the roadmap. If uncertain, assign to release
            99.0 (unscheduled). Early preview of later use cases is allowed when they
            share functionality with the current release.
        - id: P2
          title: Task sizing
          rule: |
            Code tasks should target the line range specified in the CONSTRAINTS
            section of the prompt (typically 250-350 lines of production code),
            touching no more than 5-7 files. Split larger features into multiple
            tasks. Combine trivial changes into one task.

            Always split implementation and tests into separate tasks. Decompose
            each feature into up to three tasks in this order: (1) types and
            interfaces, (2) implementation, (3) tests. A single task must never
            both implement and test the same feature. If the types and interfaces
            are small enough to fit within the implementation task's line budget,
            combine steps 1 and 2 into one task.

            Each task must be completable within the Claude timeout (typically
            5-10 minutes). If a task would require more than 20 agent turns, it
            is too large and must be split further. Treat timeout as a signal
            that the task needs decomposition, not retrying.
        - id: P3
          title: Task limit per batch
          rule: |
            Create no more than 10 tasks at a time. If more work is needed, create
            additional tasks after completing some of the current batch.
        - id: P4
          title: Issue structure
          rule: |
            Every issue description must be a YAML document with: deliverable_type
            (documentation or code), required_reading (mandatory), files (explicit
            paths with action: create or modify), requirements, acceptance_criteria.
            Documentation issues also include format_rule and required_sections.
        - id: P5
          title: Dependency ordering
          rule: |
            Identify what should be built first and why. PRDs before use cases,
            use cases before test suites, test suites before code, foundational code
            before features, libraries before CLI.
        - id: P6
          title: Requirement-anchored decomposition
          rule: |
            Anchor each task to specific PRD requirements by ID (e.g., prd001 R1.1,
            prd002 R2.3). Include the requirement ID(s) in the task title. Each PRD
            requirement maps to exactly one task unless the requirement exceeds the
            line budget, in which case split into implementation and test tasks that
            both reference the same requirement. Do not invent task boundaries that
            cross requirement boundaries. This makes decomposition deterministic:
            given the same PRD and release, the same set of tasks should be proposed.
        - id: P7
          title: File naming conventions
          rule: |
            Derive file names from the module or feature name established in the
            PRD or architecture document. Use the existing project naming pattern
            (snake_case for Go files, kebab-case for YAML documents). When creating
            a new package, use the name from ARCHITECTURE.yaml. Do not invent novel
            file names. If the PRD names a component "crumb", the file is crumb.go,
            not item.go or entity.go. Go packages must name the primary source file
            after the primary exported type, not the package name.
            `testutils/testutils.go` is forbidden; if the primary type is
            `DiffTest`, the file is `difftest.go`. Test files mirror source:
            `difftest_test.go`.
        - id: P8
          title: Deterministic ordering
          rule: |
            Propose tasks in a fixed canonical order. Within the same release:
            1. Documentation tasks before code tasks.
            2. Types and interfaces before implementations.
            3. Libraries and shared packages before consumers.
            4. Implementation before tests (when split into separate tasks).
            When two tasks have equal priority under these rules, order by the
            primary file path alphabetically. This ensures the same input produces
            the same task sequence.
        - id: P9
          title: Requirement granularity
          rule: |
            Code tasks target 5-8 requirements, 5-8 acceptance criteria, and 3-5
            design decisions. Documentation tasks target 2-4 requirements and 3-5
            acceptance criteria. Each PRD requirement maps to exactly one task
            requirement. Do not inflate counts by splitting a single requirement
            into sub-bullets, and do not deflate counts by merging unrelated
            requirements. If a task falls outside these ranges, re-examine the
            decomposition.
    issue_structure:
        common_fields:
            deliverable_type:
                required: true
                values: [documentation, code]
                description: What kind of deliverable this issue produces
            required_reading:
                required: true
                description: |
                    Files the agent must read before starting. List PRDs, ARCHITECTURE
                    sections, existing code, or upstream docs. This is mandatory for all
                    issues.
            files:
                required: true
                description: |
                    Explicit list of files the issue will produce or change. Each entry
                    has path (absolute from repo root), action (create or modify), and
                    optional note (purpose).
            requirements:
                required: true
                description: |
                    What needs to be built or written. Each item is a mapping with
                    `id` (R1, R2, ...) and `text` fields. Be specific and actionable.
            design_decisions:
                required: false
                description: |
                    Architecture, patterns, or constraints to follow. Each item is a
                    mapping with `id` (D1, D2, ...) and `text` fields. Optional but
                    recommended for code tasks.
            acceptance_criteria:
                required: true
                description: |
                    Checkable outcomes. Each item is a mapping with `id` (AC1, AC2, ...)
                    and `text` fields. Must be verifiable without ambiguity.
        documentation_issues:
            additional_fields:
                format_rule:
                    required: true
                    description: |
                        The rule file that governs the output format (e.g., prd-format,
                        use-case-format, test-case-format, architecture-format,
                        vision-format, specification-format, engineering-guideline-format).
                required_sections:
                    required: false
                    description: |
                        List of sections the document must contain, per the format rule.
                        For PRD: Problem, Goals, Requirements, Non-Goals, Acceptance Criteria.
                        For use case: Summary, Actor/trigger, Flow, Success criteria.
            deliverable_types:
                - type: ARCHITECTURE
                  location: docs/ARCHITECTURE.yaml
                  format_rule: architecture-format
                  when: Updating system overview, components, design decisions
                - type: PRD
                  location: "docs/specs/product-requirements/prd[NNN]-[feature-name].yaml"
                  format_rule: prd-format
                  when: New or updated product requirements
                - type: Use case
                  location: "docs/specs/use-cases/rel[NN].[N]-uc[NNN]-[short-name].yaml"
                  format_rule: use-case-format
                  when: Tracer-bullet flows, actor/trigger, demo criteria
                - type: Test suite
                  location: "docs/specs/test-suites/test-rel-[release-id].yaml"
                  format_rule: test-case-format
                  when: Release-level test coverage spec; use cases as sub-sections
                - type: Engineering guideline
                  location: "docs/engineering/eng[NN]-[short-name].md"
                  format_rule: engineering-guideline-format
                  when: Conventions and practices
                - type: Specification
                  location: docs/SPECIFICATIONS.md
                  format_rule: specification-format
                  when: Summary of PRDs, use cases, test suites, roadmap
        yaml_quality:
            - Use ASCII dashes (--), not Unicode em dashes or en dashes.
            - Requirements, design decisions, and acceptance criteria are all mappings with id and text fields.
        code_issues:
            rules:
                - No PRD-style Problem/Goals/Non-Goals sections in code issues
                - "Requirements focus on implementation: interfaces, operations, tests"
                - Design decisions reference PRDs and architecture patterns
                - Acceptance criteria include tests passing and behavior verified
    example_documentation_issue: |
        deliverable_type: documentation
        format_rule: prd-format

        required_reading:
          - docs/ARCHITECTURE.yaml (components section)
          - docs/specs/product-requirements/prd001-hello-world-binary.yaml

        files:
          - path: docs/specs/product-requirements/prd-feature-name.yaml
            action: create

        required_sections:
          - "Problem: explain the problem and why it matters"
          - "Goals: G1 ..., G2 ..."
          - "Requirements: R1.1 ..., R1.2 ..."
          - "Non-Goals: what is out of scope"
          - "Acceptance Criteria: checkable outcomes"

        acceptance_criteria:
          - id: AC1
            text: All required sections present
          - id: AC2
            text: File saved as prd-feature-name.yaml
          - id: AC3
            text: Requirements numbered and specific
    example_code_issue: |
        deliverable_type: code

        required_reading:
          - docs/specs/product-requirements/prd003-crumbs-interface.yaml
          - cmd/sdd-hello-world/main.go

        files:
          - path: pkg/types/crumb.go
            action: create
            note: Crumb struct, Filter type
          - path: internal/sqlite/crumbs.go
            action: create
            note: CrumbTable implementation
          - path: internal/sqlite/crumbs_test.go
            action: create
            note: tests

        requirements:
          - id: R1
            text: Implement CrumbTable interface per prd003-crumbs-interface
          - id: R2
            text: Add, Get, Archive, Purge, Fetch operations
          - id: R3
            text: Property operations (Set/Get/Clear)

        design_decisions:
          - id: D1
            text: Follow binary structure from prd001-hello-world-binary
          - id: D2
            text: Filter as map[string]any per PRD

        acceptance_criteria:
          - id: AC1
            text: All CrumbTable operations implemented
          - id: AC2
            text: Tests pass for each operation
          - id: AC3
            text: Errors match PRD error types
    sections:
        - tag: articles
          title: Core Principles
          content: |
            Three principles govern the planning phase: decompose work to fit within
            one session, write specifications before code, and never create
            implementation issues without an existing test suite for the use case.
        - tag: issue_structure
          title: Issue Structure
          content: |
            All issues share five common fields: deliverable_type, required_reading,
            files, requirements, and acceptance_criteria. Documentation issues add
            format_rule and required_sections. Code issues specify files to modify
            with explicit actions and size constraints.
        - tag: example_documentation_issue
          title: Documentation Issue Example
          content: |
            A worked example shows a properly structured documentation issue for
            writing a PRD, including required reading, output path, format rule, and
            acceptance criteria.
        - tag: example_code_issue
          title: Code Issue Example
          content: |
            A worked example shows a properly structured code issue for implementing a
            feature, including required reading, files to create or modify,
            requirements with IDs, and acceptance criteria.
issue_format_constitution:
    schema:
        description: |
            Every issue description must be a valid YAML document conforming to this
            schema. The stitch agent parses the description as YAML to extract
            required_reading, files, requirements, and acceptance_criteria.
        required_fields:
            - deliverable_type
            - required_reading
            - files
            - requirements
            - acceptance_criteria
        optional_fields:
            - format_rule
            - required_sections
            - design_decisions
    yaml_rules:
        - rule: All strings containing colons, commas, or special YAML characters must be quoted.
          example_bad: "- R1: Implement feature: core"
          example_good: '- "R1: Implement feature: core"'
        - rule: List items are YAML mappings, not bare strings, when they have sub-fields.
          example_bad: "- Use table accessor pattern"
          example_good: |
            - id: D1
              text: Use table accessor pattern
        - rule: Use ASCII dashes (--) not Unicode em dashes or en dashes.
          example_bad: "Flag interactions — especially combined flags"
          example_good: "Flag interactions -- especially combined flags"
        - rule: Requirements, design decisions, and acceptance criteria are all mappings with id and text fields.
          example_bad: "- Use singleton pattern"
          example_good: |
            - id: D1
              text: Use singleton pattern
    field_specs:
        deliverable_type:
            type: string
            values: [documentation, code]
            required: true
            description: What kind of deliverable this issue produces.
        required_reading:
            type: list of strings
            required: true
            description: |
                Files the agent must read before starting. Each entry is a file path
                with an optional parenthetical reason. This is mandatory for all issues.
        files:
            type: list of mappings
            required: true
            sub_fields:
                path:
                    type: string
                    required: true
                    description: Absolute path from repo root.
                action:
                    type: string
                    required: true
                    values: [create, modify]
                note:
                    type: string
                    required: false
                    description: Brief purpose of this file change.
        requirements:
            type: list of mappings
            required: true
            sub_fields:
                id:
                    type: string
                    required: true
                    description: "Sequential ID: R1, R2, R3, ..."
                text:
                    type: string
                    required: true
                    description: What needs to be built or written. Be specific and actionable.
        design_decisions:
            type: list of mappings
            required: false
            sub_fields:
                id:
                    type: string
                    required: true
                    description: "Sequential ID: D1, D2, D3, ..."
                text:
                    type: string
                    required: true
                    description: The decision text.
        acceptance_criteria:
            type: list of mappings
            required: true
            sub_fields:
                id:
                    type: string
                    required: true
                    description: "Sequential ID: AC1, AC2, AC3, ..."
                text:
                    type: string
                    required: true
                    description: Checkable outcome. Must be verifiable without ambiguity.
        format_rule:
            type: string
            required: false
            description: |
                For documentation issues only. The rule file that governs the output
                format (e.g., prd-format, use-case-format).
        required_sections:
            type: list of strings
            required: false
            description: |
                For documentation issues only. Sections the document must contain.
    examples:
        code_issue: |
            deliverable_type: code

            required_reading:
              - docs/specs/product-requirements/prd003-crumbs-interface.yaml
              - pkg/types/cupboard.go

            files:
              - path: pkg/types/crumb.go
                action: create
                note: Crumb struct, Filter type
              - path: internal/sqlite/crumbs.go
                action: create
                note: CrumbTable implementation

            requirements:
              - id: R1
                text: Implement CrumbTable interface per prd003-crumbs-interface
              - id: R2
                text: Add, Get, Archive, Purge, Fetch operations
              - id: R3
                text: Property operations (Set/Get/Clear)

            design_decisions:
              - id: D1
                text: Use table accessor pattern from prd001-cupboard-core
              - id: D2
                text: Filter as map[string]any per PRD

            acceptance_criteria:
              - id: AC1
                text: All CrumbTable operations implemented
              - id: AC2
                text: Tests pass for each operation
              - id: AC3
                text: Errors match PRD error types
        documentation_issue: |
            deliverable_type: documentation
            format_rule: prd-format

            required_reading:
              - docs/ARCHITECTURE.yaml (components section)
              - docs/specs/product-requirements/prd001-cupboard-core.yaml

            files:
              - path: docs/specs/product-requirements/prd-feature-name.yaml
                action: create

            required_sections:
              - "Problem: explain the problem and why it matters"
              - "Goals: G1 ..., G2 ..."
              - "Requirements: R1.1 ..., R1.2 ..."
              - "Non-Goals: what is out of scope"
              - "Acceptance Criteria: checkable outcomes"

            requirements:
              - id: R1
                text: Write PRD covering all identified requirements
              - id: R2
                text: Include acceptance criteria for each requirement

            acceptance_criteria:
              - id: AC1
                text: All required sections present
              - id: AC2
                text: File saved as prd-feature-name.yaml
              - id: AC3
                text: Requirements numbered and specific
    sections:
        - tag: schema
          title: Issue Schema
          content: |
            Each beads issue description is a YAML document with five required fields:
            deliverable_type, required_reading, files, requirements, and
            acceptance_criteria. Optional fields include design_decisions and
            format_rule.
        - tag: yaml_rules
          title: YAML Formatting Rules
          content: |
            Use multi-line block literals (|) for prose. Keys are lowercase with
            underscores. Avoid unnecessary quoting. Each requirement and acceptance
            criterion is a mapping with id and text fields.
        - tag: field_specs
          title: Field Specifications
          content: |
            Field specifications define the type, allowed values, whether the field is
            required, and sub-field structure for each issue description field.
        - tag: examples
          title: Examples
          content: |
            Reference examples for documentation issues and code issues show the full
            expected YAML structure, including required reading, output paths, format
            rules, requirements, and acceptance criteria.
task: |
    Follow these steps in order. Complete each step before moving to the next. Do NOT explore the filesystem, read files, or run commands unless a step explicitly asks you to. All project information is already provided in the project_context field above.

    1. **Analyze project context** — Review the project_context field above. It contains ALL project documentation: vision, architecture, specifications, roadmap, PRDs, use cases, test suites, engineering guidelines, constitutions, and existing issues. Do NOT read any files — everything you need is inline.

    2. **Summarize project state** — Write a brief summary of:
       - What problem this project solves
       - The high-level architecture (major components and how they fit together)
       - Current state of implementation (what is done, what is in progress)
       - Current release: which release we are working on, which use cases remain (check the roadmap)

    3. **Reason about priorities** — Determine what to build next using release priority:
       - Focus on the earliest incomplete release in the roadmap
       - Later use cases can be partially implemented if they share functionality with the current release
       - Each issue should map to a use case in the roadmap; if uncertain, use release 99.0 (unscheduled)
       - Identify dependencies: what must be built first and why

    4. **Propose tasks** — For each task, write a description that follows the crumb-format YAML schema (see planning_constitution above and output_format below). Remember: the stitch agent sees ONLY the task description and the execution constitution. It does not see your analysis, the existing issues, or this conversation. The description must be self-contained.

    5. **Return output** — Return the proposed tasks as a YAML list in your text output, inside a fenced code block marked ```yaml. Do NOT use any tools. Your entire response is text only.
constraints: |
    - Do NOT use any tools. Do NOT explore the filesystem, read files, or run commands. All project information is in the project_context above. Your response must be text only with zero tool calls.
    - Do NOT interact with the issue tracker directly.
    - Do NOT duplicate existing issues. Review the issues in the project_context above before proposing.
    - Issues with status "closed" represent COMPLETED work. Do not re-propose work that a closed issue already covers, even under a different title or framing. The completed_work field in project_context lists all finished tasks — treat every entry as work that must not be repeated.
    - When source_code contains .go files for a package, that package already exists. Do not propose creating or reimplementing it. Trust the source code over prose descriptions in documentation (e.g., implementation_status sections in ARCHITECTURE.yaml may be stale).
    - Do NOT exceed 1 tasks. If more work is needed, create additional tasks in a future session.
    - Do NOT create tasks larger than 350 lines of production code. Target 250-350 lines per task, touching 5-7 files. Split aggressively: a task that creates a struct and implements its methods is two tasks.
    - Each task must contain at most 0 requirements. Split any task that would exceed this limit.
    - Each task MUST be independently executable by an agent that has no context beyond the task description and the execution constitution.
    - Do NOT assume the stitch agent has access to your analysis, the existing issues list, or any context from this conversation.
    - Do NOT propose tasks that require human judgment or manual testing. Each task must have checkable acceptance criteria.
    - Anchor every task to specific PRD requirement IDs (e.g., prd001 R1.1). Include the requirement ID in the task title. Given the same PRD and release, the same tasks should be proposed regardless of how many times this prompt is run.
    - Order tasks canonically: documentation before code, types before implementations, libraries before consumers, implementation before tests. Break ties by primary file path alphabetically.
    - Derive file names from PRD/architecture names, not invented names. If the architecture calls a component "crumb", the file is crumb.go.
    - Do NOT invent design decisions not derived from the PRD or architecture. Derive struct shapes, timeout strategies, file names, and naming conventions from the PRD rather than making arbitrary choices. If the PRD does not specify a detail, omit it from design decisions rather than inventing one.
    - When a PRD specifies a concrete design choice (e.g., "use a FileExpectation struct", "the main file is difftest.go", "timeout is configurable via context"), copy that choice verbatim into the task's design_decisions. Do not rephrase, generalize, or substitute alternatives. The PRD is the single source of truth for implementation details.
    - Do NOT vary requirement count between equivalent runs. Each PRD requirement maps to one task requirement. Given the same input, produce the same requirement set. If two runs of this prompt against the same project state would produce different requirements, the decomposition is under-constrained -- tighten it.
    - Do NOT make any tool calls. Return the YAML list directly in your text output.
output_format: |
    Return a YAML list of crumb objects inside a fenced code block (```yaml). Each crumb has a sequential `index` (starting at 0) and a `dependency` field. Set `dependency` to the index of the crumb that must be completed first, or `-1` if there are no dependencies.

    The `description` field must be a valid YAML document conforming to the issue_format_constitution injected above. Write it as a YAML literal block scalar. Use ASCII dashes, not Unicode em dashes. Requirements, design decisions, and acceptance criteria are all mappings with `id:` and `text:` fields (R1/R2/..., D1/D2/..., AC1/AC2/...).

    Example:
      - index: 0
        title: Task title
        dependency: -1
        description: |
          deliverable_type: code

          required_reading:
            - path/to/file.go (reason this file must be read)
            - docs/specs/product-requirements/prd001-feature.yaml

          files:
            - path: pkg/types/example.go
              action: create
              note: ExampleType struct and interface
            - path: internal/example/example.go
              action: create
              note: ExampleType implementation

          requirements:
            - id: R1
              text: Implement ExampleType per prd001-feature R2
            - id: R2
              text: Add Get and Set operations

          design_decisions:
            - id: D1
              text: Follow binary structure from prd001-hello-world-binary
            - id: D2
              text: "Keep implementation in internal/, not pkg/"

          acceptance_criteria:
            - id: AC1
              text: All operations implemented and tested
            - id: AC2
              text: Tests pass for each operation

      - index: 1
        title: Task that depends on task 0
        dependency: 0
        description: |
          deliverable_type: code

          required_reading:
            - pkg/types/example.go (ExampleType contract from task 0)

          files:
            - path: internal/example/example_test.go
              action: create
              note: integration tests

          requirements:
            - id: R1
              text: Test all ExampleType operations end to end

          acceptance_criteria:
            - id: AC1
              text: All tests pass

    The description must be self-contained. All five fields (deliverable_type, required_reading, files, requirements, acceptance_criteria) are required. Each requirement, design_decision, and acceptance_criteria entry is a mapping with `id` and `text` fields. Add design_decisions when the stitch agent must follow specific patterns or architecture constraints.

    When a golden_example field is present in this prompt, it is the authoritative reference for style, granularity, and naming conventions. Match its requirement count range, acceptance criteria density, design decision style, and file naming pattern. Deviate from the golden example only when the PRD explicitly requires a different structure.

    The orchestrator will parse the YAML from your text output and import the tasks into the issue tracker.
