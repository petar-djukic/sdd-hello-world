# Planning Constitution
#
# This constitution governs the measure phase: analyzing the project state,
# breaking down work, and proposing issues. It is injected into the measure
# prompt so Claude knows how to create well-formed, appropriately sized tasks.

articles:
  - id: P1
    title: Release-driven priority
    rule: |
      Focus on the earliest incomplete release from road-map.yaml. Every issue
      should map to a use case in the roadmap. If uncertain, assign to release
      99.0 (unscheduled). Early preview of later use cases is allowed when they
      share functionality with the current release.

  - id: P2
    title: Task sizing
    rule: |
      Code tasks should target the line range specified in the CONSTRAINTS
      section of the prompt (typically 250-350 lines of production code),
      touching no more than 5-7 files. Split larger features into multiple
      tasks. Combine trivial changes into one task.

      Always split implementation and tests into separate tasks. Decompose
      each feature into up to three tasks in this order: (1) types and
      interfaces, (2) implementation, (3) tests. A single task must never
      both implement and test the same feature. If the types and interfaces
      are small enough to fit within the implementation task's line budget,
      combine steps 1 and 2 into one task.

      Each task must be completable within the Claude timeout (typically
      5-10 minutes). If a task would require more than 20 agent turns, it
      is too large and must be split further. Treat timeout as a signal
      that the task needs decomposition, not retrying.

  - id: P3
    title: Task limit per batch
    rule: |
      Create no more than 10 tasks at a time. If more work is needed, create
      additional tasks after completing some of the current batch.

  - id: P4
    title: Issue structure
    rule: |
      Every issue description must be a YAML document with: deliverable_type
      (documentation or code), required_reading (mandatory), files (explicit
      paths with action: create or modify), requirements, acceptance_criteria.
      Documentation issues also include format_rule and required_sections.

  - id: P5
    title: Dependency ordering
    rule: |
      Identify what should be built first and why. PRDs before use cases,
      use cases before test suites, test suites before code, foundational code
      before features, libraries before CLI.

  - id: P6
    title: Requirement-anchored decomposition
    rule: |
      Anchor each task to specific PRD requirements by ID (e.g., prd001 R1.1,
      prd002 R2.3). Include the requirement ID(s) in the task title. Each PRD
      requirement maps to exactly one task unless the requirement exceeds the
      line budget, in which case split into implementation and test tasks that
      both reference the same requirement. Do not invent task boundaries that
      cross requirement boundaries. This makes decomposition deterministic:
      given the same PRD and release, the same set of tasks should be proposed.

  - id: P7
    title: File naming conventions
    rule: |
      Derive file names from the module or feature name established in the
      PRD or architecture document. Use the existing project naming pattern
      (snake_case for Go files, kebab-case for YAML documents). When creating
      a new package, use the name from ARCHITECTURE.yaml. Do not invent novel
      file names. If the PRD names a component "crumb", the file is crumb.go,
      not item.go or entity.go. Go packages must name the primary source file
      after the primary exported type, not the package name.
      `testutils/testutils.go` is forbidden; if the primary type is
      `DiffTest`, the file is `difftest.go`. Test files mirror source:
      `difftest_test.go`.

  - id: P8
    title: Deterministic ordering
    rule: |
      Propose tasks in a fixed canonical order. Within the same release:
      1. Documentation tasks before code tasks.
      2. Types and interfaces before implementations.
      3. Libraries and shared packages before consumers.
      4. Implementation before tests (when split into separate tasks).
      When two tasks have equal priority under these rules, order by the
      primary file path alphabetically. This ensures the same input produces
      the same task sequence.

  - id: P9
    title: Requirement granularity
    rule: |
      Code tasks target 5-8 requirements, 5-8 acceptance criteria, and 3-5
      design decisions. Documentation tasks target 2-4 requirements and 3-5
      acceptance criteria. Each PRD requirement maps to exactly one task
      requirement. Do not inflate counts by splitting a single requirement
      into sub-bullets, and do not deflate counts by merging unrelated
      requirements. If a task falls outside these ranges, re-examine the
      decomposition.

issue_structure:
  common_fields:
    deliverable_type:
      required: true
      values: [documentation, code]
      description: What kind of deliverable this issue produces

    required_reading:
      required: true
      description: |
        Files the agent must read before starting. List PRDs, ARCHITECTURE
        sections, existing code, or upstream docs. This is mandatory for all
        issues.

    files:
      required: true
      description: |
        Explicit list of files the issue will produce or change. Each entry
        has path (absolute from repo root), action (create or modify), and
        optional note (purpose).

    requirements:
      required: true
      description: |
        What needs to be built or written. Each item is a mapping with
        `id` (R1, R2, ...) and `text` fields. Be specific and actionable.

    design_decisions:
      required: false
      description: |
        Architecture, patterns, or constraints to follow. Each item is a
        mapping with `id` (D1, D2, ...) and `text` fields. Optional but
        recommended for code tasks.

    acceptance_criteria:
      required: true
      description: |
        Checkable outcomes. Each item is a mapping with `id` (AC1, AC2, ...)
        and `text` fields. Must be verifiable without ambiguity.

  documentation_issues:
    additional_fields:
      format_rule:
        required: true
        description: |
          The rule file that governs the output format (e.g., prd-format,
          use-case-format, test-case-format, architecture-format,
          vision-format, specification-format, engineering-guideline-format).

      required_sections:
        required: false
        description: |
          List of sections the document must contain, per the format rule.
          For PRD: Problem, Goals, Requirements, Non-Goals, Acceptance Criteria.
          For use case: Summary, Actor/trigger, Flow, Success criteria.

    deliverable_types:
      - type: ARCHITECTURE
        location: docs/ARCHITECTURE.yaml
        format_rule: architecture-format
        when: Updating system overview, components, design decisions

      - type: PRD
        location: "docs/specs/product-requirements/prd[NNN]-[feature-name].yaml"
        format_rule: prd-format
        when: New or updated product requirements

      - type: Use case
        location: "docs/specs/use-cases/rel[NN].[N]-uc[NNN]-[short-name].yaml"
        format_rule: use-case-format
        when: Tracer-bullet flows, actor/trigger, demo criteria

      - type: Test suite
        location: "docs/specs/test-suites/test-rel-[release-id].yaml"
        format_rule: test-case-format
        when: Release-level test coverage spec; use cases as sub-sections

      - type: Engineering guideline
        location: "docs/engineering/eng[NN]-[short-name].md"
        format_rule: engineering-guideline-format
        when: Conventions and practices

      - type: Specification
        location: docs/SPECIFICATIONS.md
        format_rule: specification-format
        when: Summary of PRDs, use cases, test suites, roadmap

  yaml_quality:
    - Use ASCII dashes (--), not Unicode em dashes or en dashes.
    - Requirements, design decisions, and acceptance criteria are all mappings with id and text fields.

  code_issues:
    rules:
      - No PRD-style Problem/Goals/Non-Goals sections in code issues
      - "Requirements focus on implementation: interfaces, operations, tests"
      - Design decisions reference PRDs and architecture patterns
      - Acceptance criteria include tests passing and behavior verified

example_documentation_issue: |
  deliverable_type: documentation
  format_rule: prd-format

  required_reading:
    - docs/ARCHITECTURE.yaml (components section)
    - docs/specs/product-requirements/prd001-cupboard-core.yaml

  files:
    - path: docs/specs/product-requirements/prd-feature-name.yaml
      action: create

  required_sections:
    - "Problem: explain the problem and why it matters"
    - "Goals: G1 ..., G2 ..."
    - "Requirements: R1.1 ..., R1.2 ..."
    - "Non-Goals: what is out of scope"
    - "Acceptance Criteria: checkable outcomes"

  acceptance_criteria:
    - id: AC1
      text: All required sections present
    - id: AC2
      text: File saved as prd-feature-name.yaml
    - id: AC3
      text: Requirements numbered and specific

example_code_issue: |
  deliverable_type: code

  required_reading:
    - docs/specs/product-requirements/prd003-crumbs-interface.yaml
    - pkg/types/cupboard.go

  files:
    - path: pkg/types/crumb.go
      action: create
      note: Crumb struct, Filter type
    - path: internal/sqlite/crumbs.go
      action: create
      note: CrumbTable implementation
    - path: internal/sqlite/crumbs_test.go
      action: create
      note: tests

  requirements:
    - id: R1
      text: Implement CrumbTable interface per prd003-crumbs-interface
    - id: R2
      text: Add, Get, Archive, Purge, Fetch operations
    - id: R3
      text: Property operations (Set/Get/Clear)

  design_decisions:
    - id: D1
      text: Use table accessor pattern from prd001-cupboard-core
    - id: D2
      text: Filter as map[string]any per PRD

  acceptance_criteria:
    - id: AC1
      text: All CrumbTable operations implemented
    - id: AC2
      text: Tests pass for each operation
    - id: AC3
      text: Errors match PRD error types

sections:
  - tag: articles
    title: Core Principles
    content: |
      Three principles govern the planning phase: decompose work to fit within
      one session, write specifications before code, and never create
      implementation issues without an existing test suite for the use case.
  - tag: issue_structure
    title: Issue Structure
    content: |
      All issues share five common fields: deliverable_type, required_reading,
      files, requirements, and acceptance_criteria. Documentation issues add
      format_rule and required_sections. Code issues specify files to modify
      with explicit actions and size constraints.
  - tag: example_documentation_issue
    title: Documentation Issue Example
    content: |
      A worked example shows a properly structured documentation issue for
      writing a PRD, including required reading, output path, format rule, and
      acceptance criteria.
  - tag: example_code_issue
    title: Code Issue Example
    content: |
      A worked example shows a properly structured code issue for implementing a
      feature, including required reading, files to create or modify,
      requirements with IDs, and acceptance criteria.
